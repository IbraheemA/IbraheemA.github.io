"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startPerformanceCollection = startPerformanceCollection;
var browser_core_1 = require("@datadog/browser-core");
var performanceObservable_1 = require("./performanceObservable");
function supportPerformanceObject() {
    return window.performance !== undefined && 'getEntries' in performance;
}
function startPerformanceCollection(lifeCycle, configuration) {
    var cleanupTasks = [];
    if (supportPerformanceObject()) {
        var performanceEntries_1 = performance.getEntries();
        // Because the performance entry list can be quite large
        // delay the computation to prevent the SDK from blocking the main thread on init
        (0, browser_core_1.setTimeout)(function () { return handleRumPerformanceEntries(lifeCycle, performanceEntries_1); });
    }
    if (window.PerformanceObserver) {
        var handlePerformanceEntryList_1 = (0, browser_core_1.monitor)(function (entries) {
            return handleRumPerformanceEntries(lifeCycle, entries.getEntries());
        });
        var mainEntries = [performanceObservable_1.RumPerformanceEntryType.LONG_TASK, performanceObservable_1.RumPerformanceEntryType.PAINT];
        var experimentalEntries = [
            performanceObservable_1.RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT,
            performanceObservable_1.RumPerformanceEntryType.FIRST_INPUT,
            performanceObservable_1.RumPerformanceEntryType.LAYOUT_SHIFT,
            performanceObservable_1.RumPerformanceEntryType.EVENT,
        ];
        try {
            // Experimental entries are not retrieved by performance.getEntries()
            // use a single PerformanceObserver with buffered flag by type
            // to get values that could happen before SDK init
            experimentalEntries.forEach(function (type) {
                var observer = new window.PerformanceObserver(handlePerformanceEntryList_1);
                observer.observe({
                    type: type,
                    buffered: true,
                    // durationThreshold only impact PerformanceEventTiming entries used for INP computation which requires a threshold at 40 (default is 104ms)
                    // cf: https://github.com/GoogleChrome/web-vitals/blob/3806160ffbc93c3c4abf210a167b81228172b31c/src/onINP.ts#L209
                    durationThreshold: 40,
                });
                cleanupTasks.push(function () { return observer.disconnect(); });
            });
        }
        catch (e) {
            // Some old browser versions (ex: chrome 67) don't support the PerformanceObserver type and buffered options
            // In these cases, fallback to PerformanceObserver with entryTypes
            mainEntries.push.apply(mainEntries, experimentalEntries);
        }
        var mainObserver_1 = new PerformanceObserver(handlePerformanceEntryList_1);
        try {
            mainObserver_1.observe({ entryTypes: mainEntries });
            cleanupTasks.push(function () { return mainObserver_1.disconnect(); });
        }
        catch (_a) {
            // Old versions of Safari are throwing "entryTypes contained only unsupported types"
            // errors when observing only unsupported entry types.
            //
            // We could use `supportPerformanceTimingEvent` to make sure we don't invoke
            // `observer.observe` with an unsupported entry type, but Safari 11 and 12 don't support
            // `Performance.supportedEntryTypes`, so doing so would lose support for these versions
            // even if they do support the entry type.
        }
        if (supportPerformanceObject() && 'addEventListener' in performance) {
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377
            var removePerformanceListener = (0, browser_core_1.addEventListener)(configuration, performance, 'resourcetimingbufferfull', function () {
                performance.clearResourceTimings();
            }).stop;
            cleanupTasks.push(removePerformanceListener);
        }
    }
    if (!(0, performanceObservable_1.supportPerformanceTimingEvent)(performanceObservable_1.RumPerformanceEntryType.FIRST_INPUT)) {
        var stopFirstInputTiming = retrieveFirstInputTiming(configuration, function (timing) {
            handleRumPerformanceEntries(lifeCycle, [timing]);
        }).stop;
        cleanupTasks.push(stopFirstInputTiming);
    }
    return {
        stop: function () {
            cleanupTasks.forEach(function (task) { return task(); });
        },
    };
}
/**
 * first-input timing entry polyfill based on
 * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts
 */
function retrieveFirstInputTiming(configuration, callback) {
    var startTimeStamp = (0, browser_core_1.dateNow)();
    var timingSent = false;
    var removeEventListeners = (0, browser_core_1.addEventListeners)(configuration, window, ["click" /* DOM_EVENT.CLICK */, "mousedown" /* DOM_EVENT.MOUSE_DOWN */, "keydown" /* DOM_EVENT.KEY_DOWN */, "touchstart" /* DOM_EVENT.TOUCH_START */, "pointerdown" /* DOM_EVENT.POINTER_DOWN */], function (evt) {
        // Only count cancelable events, which should trigger behavior important to the user.
        if (!evt.cancelable) {
            return;
        }
        // This timing will be used to compute the "first Input delay", which is the delta between
        // when the system received the event (e.g. evt.timeStamp) and when it could run the callback
        // (e.g. performance.now()).
        var timing = {
            entryType: performanceObservable_1.RumPerformanceEntryType.FIRST_INPUT,
            processingStart: (0, browser_core_1.relativeNow)(),
            processingEnd: (0, browser_core_1.relativeNow)(),
            startTime: evt.timeStamp,
            duration: 0, // arbitrary value to avoid nullable duration and simplify INP logic
            name: '',
        };
        if (evt.type === "pointerdown" /* DOM_EVENT.POINTER_DOWN */) {
            sendTimingIfPointerIsNotCancelled(configuration, timing);
        }
        else {
            sendTiming(timing);
        }
    }, { passive: true, capture: true }).stop;
    return { stop: removeEventListeners };
    /**
     * Pointer events are a special case, because they can trigger main or compositor thread behavior.
     * We differentiate these cases based on whether or not we see a pointercancel event, which are
     * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes
     * scrolling and pinch/zooming.
     */
    function sendTimingIfPointerIsNotCancelled(configuration, timing) {
        (0, browser_core_1.addEventListeners)(configuration, window, ["pointerup" /* DOM_EVENT.POINTER_UP */, "pointercancel" /* DOM_EVENT.POINTER_CANCEL */], function (event) {
            if (event.type === "pointerup" /* DOM_EVENT.POINTER_UP */) {
                sendTiming(timing);
            }
        }, { once: true });
    }
    function sendTiming(timing) {
        if (!timingSent) {
            timingSent = true;
            removeEventListeners();
            // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than
            // the time between now and when the page was loaded.
            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4
            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6
            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7
            var delay = timing.processingStart - timing.startTime;
            if (delay >= 0 && delay < (0, browser_core_1.dateNow)() - startTimeStamp) {
                callback(timing);
            }
        }
    }
}
function handleRumPerformanceEntries(lifeCycle, entries) {
    var rumPerformanceEntries = entries.filter(function (entry) {
        return (0, browser_core_1.objectHasValue)(performanceObservable_1.RumPerformanceEntryType, entry.entryType);
    });
    if (rumPerformanceEntries.length) {
        lifeCycle.notify(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, rumPerformanceEntries);
    }
}
//# sourceMappingURL=performanceCollection.js.map
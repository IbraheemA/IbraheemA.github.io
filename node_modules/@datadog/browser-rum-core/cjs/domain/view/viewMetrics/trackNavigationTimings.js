"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackNavigationTimings = trackNavigationTimings;
var browser_core_1 = require("@datadog/browser-core");
var performanceUtils_1 = require("../../../browser/performanceUtils");
var performanceObservable_1 = require("../../../browser/performanceObservable");
function trackNavigationTimings(configuration, callback) {
    var processEntry = function (entry) {
        if (!isIncompleteNavigation(entry)) {
            callback(processNavigationEntry(entry));
        }
    };
    var stop = browser_core_1.noop;
    if ((0, performanceObservable_1.supportPerformanceTimingEvent)(performanceObservable_1.RumPerformanceEntryType.NAVIGATION)) {
        ;
        (stop = (0, performanceObservable_1.createPerformanceObservable)(configuration, {
            type: performanceObservable_1.RumPerformanceEntryType.NAVIGATION,
            buffered: true,
        }).subscribe(function (entries) { return (0, browser_core_1.forEach)(entries, processEntry); }).unsubscribe);
    }
    else {
        retrieveNavigationTiming(configuration, processEntry);
    }
    return { stop: stop };
}
function processNavigationEntry(entry) {
    return {
        domComplete: entry.domComplete,
        domContentLoaded: entry.domContentLoadedEventEnd,
        domInteractive: entry.domInteractive,
        loadEvent: entry.loadEventEnd,
        // In some cases the value reported is negative or is larger
        // than the current page time. Ignore these cases:
        // https://github.com/GoogleChrome/web-vitals/issues/137
        // https://github.com/GoogleChrome/web-vitals/issues/162
        firstByte: entry.responseStart >= 0 && entry.responseStart <= (0, browser_core_1.relativeNow)() ? entry.responseStart : undefined,
    };
}
function isIncompleteNavigation(entry) {
    return entry.loadEventEnd <= 0;
}
function retrieveNavigationTiming(configuration, callback) {
    (0, browser_core_1.runOnReadyState)(configuration, 'complete', function () {
        // Send it a bit after the actual load event, so the "loadEventEnd" timing is accurate
        (0, browser_core_1.setTimeout)(function () { return callback((0, performanceUtils_1.computeRelativePerformanceTiming)()); });
    });
}
//# sourceMappingURL=trackNavigationTimings.js.map